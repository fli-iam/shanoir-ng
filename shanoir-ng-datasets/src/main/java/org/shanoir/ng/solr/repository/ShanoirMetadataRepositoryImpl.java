/**
 * Shanoir NG - Import, manage and share neuroimaging data
 * Copyright (C) 2009-2019 Inria - https://www.inria.fr/
 * Contact us on https://project.inria.fr/shanoir/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see https://www.gnu.org/licenses/gpl-3.0.html
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program (2.2.3).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package org.shanoir.ng.solr.repository;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import org.shanoir.ng.solr.model.ShanoirMetadata;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.*;
import java.util.stream.Collectors;

/**
 * @author yyao
 * @author mkain
 *
 */
@Component
@SuppressWarnings("unchecked")
public class ShanoirMetadataRepositoryImpl implements ShanoirMetadataRepositoryCustom {

    private static final Logger LOG = LoggerFactory.getLogger(ShanoirMetadataRepositoryImpl.class);
    private static final String MR_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "mdm.mr_dataset_nature as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "e.id as examinationId, "
            + "e.comment as examinationComment, "
            + "e.examination_date as examinationDate, "
            + "ae.name as acquisitionEquipmentName, "
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, "
            + "e.study_id as studyId, "
            + "c.name as centerName, "
            + "c.id as centerId, mrp.slice_thickness as sliceThickness, "
            + "mrp.pixel_bandwidth as pixelBandwidth, "
            + "mrp.magnetic_field_strength as magneticFieldStrength, "
            + "da.import_date as importDate, "
            + "da.username as username, "
            + "da.sorting_index as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset_acquisition da on da.id = d.dataset_acquisition_id"
            + " LEFT JOIN mr_dataset_acquisition mda on mda.id = d.dataset_acquisition_id"
            + " LEFT JOIN mr_protocol mrp on mrp.id = mda.mr_protocol_id"
            + " LEFT JOIN examination e ON e.id = da.examination_id"
            + " LEFT JOIN acquisition_equipment ae ON ae.id = da.acquisition_equipment_id"
            + " LEFT JOIN study st ON st.id = e.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = e.study_id"
            + " LEFT JOIN center c ON c.id = e.center_id"
            + " , dataset_metadata dm, mr_dataset md"
            + " LEFT JOIN mr_dataset_metadata mdm ON md.updated_mr_metadata_id = mdm.id"
            + " WHERE d.updated_metadata_id = dm.id AND md.id = d.id";
    private static final String PET_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "null as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "e.id as examinationId, "
            + "e.comment as examinationComment, "
            + "e.examination_date as examinationDate, "
            + "ae.name as acquisitionEquipmentName, "
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, e.study_id as studyId, c.name as centerName, "
            + "c.id as centerId, null as sliceThickness, "
            + "null as pixelBandwidth, "
            + "null as magneticFieldStrength, "
            + "da.import_date as importDate, "
            + "da.username as username, "
            + "da.sorting_index as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset_acquisition da on da.id = d.dataset_acquisition_id"
            + " LEFT JOIN examination e ON e.id = da.examination_id"
            + " LEFT JOIN acquisition_equipment ae ON ae.id = da.acquisition_equipment_id"
            + " LEFT JOIN study st ON st.id = e.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = e.study_id"
            + " LEFT JOIN center c ON c.id = e.center_id"
            + " , pet_dataset pd, dataset_metadata dm"
            + " WHERE d.updated_metadata_id = dm.id AND pd.id = d.id";
    private static final String CT_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "null as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "e.id as examinationId, "
            + "e.comment as examinationComment, "
            + "e.examination_date as examinationDate, "
            + "ae.name as acquisitionEquipmentName, "
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, "
            + "e.study_id as studyId, "
            + "c.name as centerName, c.id as centerId, "
            + "null as sliceThickness, "
            + "null as pixelBandwidth, "
            + "null as magneticFieldStrength, "
            + "da.import_date as importDate, "
            + "da.username as username, "
            + "da.sorting_index as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset_acquisition da on da.id = d.dataset_acquisition_id"
            + " LEFT JOIN examination e ON e.id = da.examination_id"
            + " LEFT JOIN acquisition_equipment ae ON ae.id = da.acquisition_equipment_id"
            + " LEFT JOIN study st ON st.id = e.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = e.study_id"
            + " LEFT JOIN center c ON c.id = e.center_id"
            + " , ct_dataset cd, dataset_metadata dm"
            + " WHERE d.updated_metadata_id = dm.id AND cd.id = d.id";
    private static final String GENERIC_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "null as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "e.id as examinationId, "
            + "e.comment as examinationComment, "
            + "e.examination_date as examinationDate, "
            + "ae.name as acquisitionEquipmentName, "
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, "
            + "e.study_id as studyId, "
            + "c.name as centerName, "
            + "c.id as centerId, "
            + "null as sliceThickness, "
            + "null as pixelBandwidth, "
            + "null as magneticFieldStrength, "
            + "da.import_date as importDate, "
            + "da.username as username, "
            + "da.sorting_index as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset_acquisition da on da.id = d.dataset_acquisition_id"
            + " LEFT JOIN examination e ON e.id = da.examination_id"
            + " LEFT JOIN acquisition_equipment ae ON ae.id = da.acquisition_equipment_id"
            + " LEFT JOIN study st ON st.id = e.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = e.study_id"
            + " LEFT JOIN center c ON c.id = e.center_id"
            + " , generic_dataset cd, dataset_metadata dm"
            + " WHERE d.updated_metadata_id = dm.id AND cd.id = d.id";
    private static final String EEG_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "null as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "e.id as examinationId, "
            + "e.comment as examinationComment, "
            + "e.examination_date as examinationDate, "
            + "ae.name as acquisitionEquipmentName, "
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, "
            + "e.study_id as studyId, "
            + "c.name as centerName, c.id as centerId, "
            + "null as sliceThickness, "
            + "null as pixelBandwidth, "
            + "null as magneticFieldStrength, "
            + "da.import_date as importDate, "
            + "da.username as username, "
            + "da.sorting_index as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset_acquisition da on da.id = d.dataset_acquisition_id"
            + " LEFT JOIN examination e ON e.id = da.examination_id"
            + " LEFT JOIN acquisition_equipment ae ON ae.id = da.acquisition_equipment_id"
            + " LEFT JOIN study st ON st.id = e.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = e.study_id"
            + " LEFT JOIN center c ON c.id = e.center_id"
            + " , eeg_dataset ed, dataset_metadata dm"
            + " WHERE d.origin_metadata_id = dm.id AND ed.id = d.id";
    private static final String BIDS_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "null as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "e.id as examinationId, "
            + "e.comment as examinationComment, "
            + "e.examination_date as examinationDate, "
            + "ae.name as acquisitionEquipmentName, "
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, "
            + "e.study_id as studyId, "
            + "c.name as centerName, "
            + "c.id as centerId, "
            + "null as sliceThickness, "
            + "null as pixelBandwidth, "
            + "null as magneticFieldStrength, "
            + "da.import_date as importDate, "
            + "da.username as username, "
            + "da.sorting_index as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset_acquisition da on da.id = d.dataset_acquisition_id"
            + " LEFT JOIN examination e ON e.id = da.examination_id"
            + " LEFT JOIN acquisition_equipment ae ON ae.id = da.acquisition_equipment_id"
            + " LEFT JOIN study st ON st.id = e.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = e.study_id"
            + " LEFT JOIN center c ON c.id = e.center_id"
            + " , bids_dataset ed, dataset_metadata dm"
            + " WHERE d.updated_metadata_id = dm.id AND ed.id = d.id";
    private static final String PROCESSED_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "null as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "null as examinationId, "
            + "null as examinationComment, "
            + "null as examinationDate, "
            + "null as acquisitionEquipmentName, "
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, "
            + "proc.study_id as studyId, "
            + "null as centerName, "
            + "null as centerId, "
            + "null as sliceThickness, "
            + "null as pixelBandwidth, "
            + "null as magneticFieldStrength, "
            + "proc.processing_date as importDate, "
            + "proc.username as username, "
            + "null as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset_processing proc ON proc.id = d.dataset_processing_id"
            + " LEFT JOIN study st ON st.id = proc.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = proc.study_id"
            + " , dataset_metadata dm"
            + " WHERE d.origin_metadata_id = dm.id"
            + " AND d.dataset_processing_id IS NOT NULL";
    private static final String MEASUREMENT_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "null as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "e.id as examinationId, "
            + "e.comment as examinationComment, "
            + "e.examination_date as examinationDate, "
            + "ae.name as acquisitionEquipmentName,"
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, "
            + "e.study_id as studyId, "
            + "c.name as centerName, "
            + "c.id as centerId, "
            + "null as sliceThickness, "
            + "null as pixelBandwidth, "
            + "null as magneticFieldStrength, "
            + "da.import_date as importDate, "
            + "da.username as username, "
            + "da.sorting_index as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset refd ON refd.id = d.referenced_dataset_for_superimposition_id"
            + " LEFT JOIN dataset_acquisition da on da.id = refd.dataset_acquisition_id"
            + " LEFT JOIN examination e ON e.id = da.examination_id"
            + " LEFT JOIN acquisition_equipment ae ON ae.id = da.acquisition_equipment_id"
            + " LEFT JOIN study st ON st.id = e.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = e.study_id"
            + " LEFT JOIN center c ON c.id = e.center_id"
            + " , measurement_dataset md, dataset_metadata dm"
            + " WHERE d.updated_metadata_id = dm.id AND md.id = d.id";
    private static final String SEGMENTATION_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "null as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "e.id as examinationId, "
            + "e.comment as examinationComment, "
            + "e.examination_date as examinationDate, "
            + "ae.name as acquisitionEquipmentName,"
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, "
            + "e.study_id as studyId, "
            + "c.name as centerName, "
            + "c.id as centerId, "
            + "null as sliceThickness, "
            + "null as pixelBandwidth, "
            + "null as magneticFieldStrength, "
            + "da.import_date as importDate, "
            + "da.username as username, "
            + "da.sorting_index as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset refd ON refd.id = d.referenced_dataset_for_superimposition_id"
            + " LEFT JOIN dataset_acquisition da on da.id = refd.dataset_acquisition_id"
            + " LEFT JOIN examination e ON e.id = da.examination_id"
            + " LEFT JOIN acquisition_equipment ae ON ae.id = da.acquisition_equipment_id"
            + " LEFT JOIN study st ON st.id = e.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = e.study_id"
            + " LEFT JOIN center c ON c.id = e.center_id"
            + " , segmentation_dataset sd, dataset_metadata dm"
            + " WHERE d.updated_metadata_id = dm.id AND sd.id = d.id";
    private static final String XA_QUERY = "SELECT d.id as datasetId, "
            + "dm.name as datasetName, "
            + "dm.dataset_modality_type as datasetType, "
            + "null as datasetNature, "
            + "d.creation_date as datasetCreationDate, "
            + "e.id as examinationId, "
            + "e.comment as examinationComment, "
            + "e.examination_date as examinationDate, "
            + "ae.name as acquisitionEquipmentName, "
            + "su.name as subjectName, "
            + "su.subject_type as subjectType, "
            + "su.id as subjectId, "
            + "st.name as studyName, "
            + "e.study_id as studyId, "
            + "c.name as centerName, "
            + "c.id as centerId, "
            + "null as sliceThickness, "
            + "null as pixelBandwidth, "
            + "null as magneticFieldStrength, "
            + "da.import_date as importDate, "
            + "da.username as username, "
            + "da.sorting_index as sortingIndex, "
            + "CASE WHEN d.dataset_processing_id IS NULL THEN 0 ELSE 1 END as processed"
            + " FROM dataset d"
            + " LEFT JOIN dataset_acquisition da on da.id = d.dataset_acquisition_id"
            + " LEFT JOIN examination e ON e.id = da.examination_id"
            + " LEFT JOIN acquisition_equipment ae ON ae.id = da.acquisition_equipment_id"
            + " LEFT JOIN study st ON st.id = e.study_id"
            + " LEFT JOIN subject su ON su.id = d.subject_id AND su.study_id = e.study_id"
            + " LEFT JOIN center c ON c.id = e.center_id"
            + " , xa_dataset cd, dataset_metadata dm"
            + " WHERE d.updated_metadata_id = dm.id AND cd.id = d.id";
    private static final String RESULTSET_MAPPING = "SolrResult";

    private static final String SUBJECT_TAG_QUERY = "SELECT d.id AS dataset_id, tag.name AS tag"
            + " FROM dataset d"
            + " INNER JOIN subject_tag subtag ON d.subject_id = subtag.subject_id"
            + " INNER JOIN tag ON subtag.tag_id = tag.id";

    private static final String STUDY_TAG_QUERY = "SELECT d.id AS dataset_id, tag.name AS tag"
            + " FROM dataset d "
            + " INNER JOIN dataset_tag dstag ON d.id = dstag.dataset_id "
            + " INNER JOIN study_tag tag ON dstag.study_tag_id = tag.id";

    private static final List<String> ACQUISITION_QUERIES = List.of(
            MR_QUERY,
            PET_QUERY,
            CT_QUERY,
            XA_QUERY,
            GENERIC_QUERY,
            EEG_QUERY,
            BIDS_QUERY,
            MEASUREMENT_QUERY,
            SEGMENTATION_QUERY
    );

    @PersistenceContext
    private EntityManager em;

    @Override
    public List<ShanoirMetadata> findAllAsSolrDoc() {
        List<ShanoirMetadata> result = new ArrayList<>();
        result.addAll(findSolrProcessed(""));
        result.addAll(findSolrAcquisitions(" AND d.dataset_processing_id IS NULL"));
        return result;
    }

    @Override
    public ShanoirMetadata findOneSolrDoc(Long datasetId) {
        List<ShanoirMetadata> processed = findSolrProcessed(" AND d.id = " + datasetId);
        if (!processed.isEmpty()) {
            if (processed.size() > 1) {
                LOG.error("Multiple processed metadata rows for dataset [{}]", datasetId);
                return null;
            }
            return processed.get(0);
        }

        List<ShanoirMetadata> acquisitions = findSolrAcquisitions(" AND d.id = " + datasetId + " AND d.dataset_processing_id IS NULL");
        if (acquisitions.isEmpty()) {
            return null;
        }
        if (acquisitions.size() > 1) {
            LOG.error("Solr query returned multiple result for dataset [{}]. Please check database consistency.", datasetId);
            return null;
        }
        return acquisitions.get(0);
    }

    @Override
    public List<ShanoirMetadata> findSolrDocs(List<Long> datasetIds) {
        if (CollectionUtils.isEmpty(datasetIds)) {
            return Collections.emptyList();
        }

        String ids = datasetIds.stream()
                .map(Object::toString)
                .collect(Collectors.joining(","));

        List<ShanoirMetadata> result = new ArrayList<>();
        result.addAll(findSolrProcessed(" AND d.id IN (" + ids + ")"));
        result.addAll(findSolrAcquisitions(" AND d.id IN (" + ids + ")" + " AND d.dataset_processing_id IS NULL"));

        return result;
    }

    private List<ShanoirMetadata> findSolrAcquisitions(String clause) {
        List<ShanoirMetadata> result = new ArrayList<>();
        for (String baseQuery : ACQUISITION_QUERIES) {
            Query query = em.createNativeQuery(baseQuery + clause, RESULTSET_MAPPING);
            result.addAll(query.getResultList());
        }
        return result;
    }

    private List<ShanoirMetadata> findSolrProcessed(String clause) {
        Query processedQuery = em.createNativeQuery(PROCESSED_QUERY + clause, RESULTSET_MAPPING);
        return processedQuery.getResultList();
    }

    @Override
    public Map<Long, List<String>> findAllTags(List<Long> datasetIds) {

        List<Object[]> result = new ArrayList<>();

        String clause = "";

        if (datasetIds != null && !datasetIds.isEmpty()) {
            String ids = datasetIds.stream().map(Object::toString).collect(Collectors.joining(","));
            clause = " AND d.id IN (" + ids + ")";
        }

        Query subjectTagQuery = em.createNativeQuery(SUBJECT_TAG_QUERY + clause);
        result.addAll(subjectTagQuery.getResultList());

        Query studyTagQuery = em.createNativeQuery(STUDY_TAG_QUERY + clause);
        result.addAll(studyTagQuery.getResultList());

        Map<Long, List<String>> tags = new HashMap<>();

        for (Object[] row : result) {
            Long id = (Long) row[0];
            tags.putIfAbsent(id, new ArrayList<>());
            tags.get(id).add((String) row[1]);
        }

        return tags;

    }
}
